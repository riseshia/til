# Ruby 2.3.0 Preview
이 글은 [Ruby Korea Advent Calendar 2015](https://ruby-korea.github.io/advent-calendar/)를 위해서 작성되었습니다.

## 들어가기 전에

이 글은 곧 릴리스될 예정인 Ruby 2.3.0에 대해 Matz, 마츠다 아키라, 미야가와 타츠히코 씨가 [Rebuild #118](http://rebuild.fm/118/)에서 나눈 이야기를 정리한 내용입니다. 완전한 번역은 아니며, 중간중간 생략된 부분 및 잘못된 부분이 있을 수 있습니다. 혹시라도 오역을 발견하시면 연락주세요 :)

## Enumerable#grep_v (inversed grep)

### Code Example

```ruby
%w(aaa bbb ccc).grep(/b/) #=> ["bbb"]
%w(aaa bbb ccc).grep_v(/b/) #=> ["aaa", "ccc"]
```

### 이야기

미야가와: Enumerable#reject랑은 뭐가 다른건가요?

Matz: reject는 조건문을 블록을 통해서 넘겨주어야하는 반면, grep는 정규표현을 사용할 수 있잖아요? 물론 아니어도 상관 없지만, 거기에 매칭되는 문자열은 남는 동작을 하는데, grep_v는 여기에서 매칭되는 문자열을 제거합니다. 정규표현을 반전시키는 코드가 생각보다 작성하기 귀찮단 말이죠. 예를 들어, 어떤 정규 표현에 매칭하지 않는 문자열을 가져오고 싶은 경우라든가.

마츠다: 하고 싶은 경우는 많은데, 쓰기 불편한 경우가..

Matz: 그래서 그런 부분을 메소드 레벨에서 처리하면 쓰기 편하지 않을까, 같은 [제안](https://bugs.ruby-lang.org/issues/11049)이 왔던 걸로 기억해요.

## Safe navigation operator

### Code Example

```ruby
u = User.find(id)
if u && u.profile && u.profile.thumbnails && u.profiles.thumbnails.large
  ...
```

위 코드를,

```ruby
u = User.find(id)
u&.profile.thumbnails&.large
```

이와 같은 방식으로 사용할 수 있게 해줍니다. 다시 말해서, '&.'를 붙이는 것으로, 값이 nil일 경우에 대한 분기 처리를 연산자 레벨에서 사용할 수 있게 됩니다.

### 이야기

미야가와: 그리고 '&.'...

Matz, 마츠다: 외톨이(ぼっち) 연산자...(웃음) 

Matz: 해외에서도 그렇게 먹힐 줄은 몰랐는데.

미야가와: 처음에 Lonely Operator라고 들으면 무슨 소리인가 할텐데요.

Matz: '&.'를 잘 들여다보면, 한 사람이 바닥에 앉아서 눈 앞에 있는 '.'을 들여다보고 있는 것으로밖에는 보이지 않는다고...

마츠다: 사람들의 반응이 좋더라구요

Matz: 그랬죠.

미야가와: 그거 한번이라도 듣게 되면, 그 이후에는 그렇게 밖에는 보이지 않게 되어서...

(전원 웃음)

Matz: 그러니 이제 아무도 잊어버리지 않을 수 있겠지, 하고.

미야가와: Swift 등에서는 '?.'가 쓰이고 있는데, Ruby에서는 이미 판정함수(true, false를 반환하는 메소드) 용으로 쓰이고 있잖아요?

Matz: 네. 메소드 마지막에 '?.'를 쓰게 되면 이미 사용되고 있는 판정함수와 구분이 모호해지니까 그렇게는 쓸 수 없죠. [Safe navigation operator의 첫 제안](https://bugs.ruby-lang.org/issues/11537)에서는 반전시켜서 메소드의 첫 머리에 물음표를 사용하자, 라는 내용이 포함되어 있었어요. 뭐, 일단 Safe navigation operator가 있으면 좋겠다는 제안 자체는 무척 끌리는 부분이라서, 그 null 패턴이라고 하나, 정당한 값이나, 또는 null을 돌려주는 방식은 꽤 자주 쓰는 방식이기 때문에, chain을 위해서 이를 적극적으로 지원했으면 한다는 부분은 이해할 수 있고요. Active Support에서도 try를 지원하고 있으니까요. 그래서 제안하는 대로 한번 코드를 작성해봤는데, 영문을 모르겠는 거에요.(웃음)

Matz: 하나는, '?.'와 '.?'가 너무 비슷해서 어느 쪽을 써야할지 가끔 혼란이 온달까, 그 뭐랄까, 심리적인 혼란이라고 적었었는데, 애매하게 비슷하면 어느쪽이 어느쪽인지 분간하기 기억하기 어려워진단 말이죠.

미야가와: 쓰는 기호도 같구요.

Matz: 예를 들어 Swift를 작성하다가, Ruby를 작성하게 되면 어떻게 작성해야하더라? 하는 혼란이 들 수 있어서, 모양이 다른 오퍼레이터를 사용하는게 좋겠다, 라고 생각한 점이 첫번째고, [---]가 제안한 &&를 쓰는 방식을 제안해서 그걸 좀 보다보니 줄여서 쓰면 깔끔하고, 명확할 것 같아서 결정된게 '&.' 오퍼레이터였다. 그리고 그렇게 제안했더니, 누구더라?

마츠다: 나카다 씨요.

Matz: 아, 나카다 씨가, 외톨이 연산자다! 라고 말하기 시작해서. 에? 하고 보다보니 앉아있는 사람이 작은 돌을 쳐다보고 있는 걸로 밖에 보이지 않게 되어서, 모두가 외톨이 연산자라고, 루비 커뮤니티에 어울리는 연산자가 생겼다고(웃음).


## Immutable String

Ruby 2.3.0에서는 String 객체를 기본으로 freeze(Immutable)하게 해주는 매직 코멘트가 추가 되었으며, Ruby 3.0에서는 String 객체가 Immutable하게 될 예정입니다. 이 부분에 대해서 잘 이해가 되지 않으시는 분은 [Weird stuff with hashes](http://www.slideshare.net/devilsia/weird-stuff-with-hasheskey)라는 발표 자료를 보시면 Immutable하지 않아서 생기는 문제 및 무엇인지에 대해서 어느 정도 이해하실 수 있습니다.

### 이야기

미야가와: 그리고, 컨퍼런스에서는 평범하게 호응을 받았다고 생각하는데, 그 리터럴 문자열을 얼린다(freeze)는 건, 일본 내랄까, 인터넷 상에서는 꽤 불만이 있었던 것으로 보였는데요.

Matz: 중요한 점은 비호환이라는 건데, 비호환은 아무래도 귀찮음을 동반하기 때문에 그건 어떤 의미에서는 당연하다고 생각해요.

미야가와: 마츠다 씨가 블로그에서 이에 관련된 사회 문제에 대해서 이야기하셨던거 같은데, 혹시 해설을 좀 해주실 수 있나요?

마츠다: 아, 제가 시작하는거군요. 이번의 기능을 설명하자면, 루비의 리터럴 문자열은 잔뜩 쓰레기가 생기는데, Rails라면 특히 이것이 심해서 퍼포먼스에 영향을 주기 때문에 이를 줄여나가자, 같은 풍조가 있어서, 2년...

Matz: 거기는 처음에 있었던 제안을 설명하는 게 낫지 않을까요? Ruby의 경우에는 리터럴 문자열을 변경할 수 있는데, 근데 변경한 뒤에 그 문자열을 두번째 참조했을 경우에 변경되어 있으면 곤란하니까, 리터럴이 등장한 시점에서 객체를 항상 하나 생성하고 있거든요, 매번. 그러니까 프로그램 안에, "abc"라고 나오면, "abc"라는 문자열을 어딘가에서 복사해와서, 그러니까 매번 복사해오고 있다는 거죠. 그러면, 리터럴이 많은 프로그램의 경우, 각각의 리터럴을 만날 때 마다 객체를 만들기 때문에 뭐, 어떤 의미에서는 쓸모 없는 객체를 만든다는 관점도 있을 수 있겠네요. 아무튼, 그래서 객체가 너무 많으면 가비지 컬렉션이 탐색해야 하는 객체 갯수가 많아져서, 그럭저럭 개선이 됬지만, 그래도 이 작업에 걸리는 시간이 길어집니다. 결과적으로 프로그램의 퍼포먼스를 저하시키는 원인이 될 수 있다는 거죠.

마츠다: 그렇죠. 이건 꽤 이전부터 Ruby 내에서도 문제로 여겨지고 있었는데, 2년 전쯤이었나, akr 씨가 처음 매직 코멘트를 쓰는 방식을 제안해왔었는데, 그 때에는 마츠모토씨가 각하했었죠?

Matz: 그 당시에는 호환/비호환의 문제도 있었고, 도입해서 얻을 수 있는 메리트가 잘 이해가 가지 않았으니까, 그 시점에서는 각하했었죠.

마츠다: 그때가 분명 Ruby 2.1에 넣을까 말까 하던 시절의 이야기였고, 그렇다면 '.freeze'를 최적화 하자는 이야기가 나와서, 리터럴 문자열 뒤에 '.freeze'라고 작성하면 메소드 호출을 매번 하는 것이 아니라, 뭐였더라, 컴파일 시점?

Matz: 네. 컴파일 시점.

마츠다: 컴파일 시점에 같은 객체를 사용하도록.

Matz: 지금까지라면 문자열 리터럴 + '.freeze' 라고 쓰면 일단 문자열 객체를 하나 만들고, 거기에 대해서 'freeze'를 호출하여 얼리던 동작이 컴파일 시점의 최적화를 허용해서, 애초에 Ruby의 어딘가에 있는 원본 객체를 그대로 보여주는 식으로 동작을 변경했어요. 그러면 객체 하나로 해결할 수 있죠.

미야가와: 그 객체는 얼려져 있으니까...

Matz: 네네. 원래 복사에 사용하던 객체는 애초에 얼려져 있으니까, 변경될 걱정이 없으니 이걸로 되겠지, 라고 생각했죠.

마츠다: 그러자, '리터럴 문자열에 '.freeze'를 붙이면 우리 애플리케이션이 빨라진대.'라는 소문이 조금씩 조금씩 퍼지기 시작해서, 최근 1년 정도, 리터럴 문자열에 '.freeze'를 추가하는 PR이 깃헙에서 여기저기 날아다니기 시작했죠. 특히 Rails와 Rails가 의존하고 있는 몇몇 라이브러리에 무시무시한 양의 '.freeze' 추가 PR이, "레일즈를 빠르게 했습니다!"같은 PR이 날아오게 되어서, 솔직히 '"".freeze'라든가, '" ".freeze'라든가, 보기에 되게 더럽거든요. 그래서 프로그램이 무척 보기 안좋아지지만, 코드가 빨라지는 것은 분명하기 때문에....

Matz: 뭐, 대부분의 경우 속도가 1순위인 경우가 대부분이기 때문에...

마츠다: 그렇죠.

Matz: 빠르게 만들기 위해서 코드가 좀 더러워지는 방법이 용납되는 경우는 많죠.

마츠다: 그렇죠.

미야가와: '낮게 달린 과일'이랄까, Rails에 공헌하고 싶은 사람이 간단하게 할 수 있으니까요.

마츠다: 결과, Rails의 코드가 점점 더러워져서...

Matz: 받는 입장에서도 기분이 그렇게 썩 좋진 않죠(웃음). '.freeze'만을 추가한 패치가 자꾸 날아와서, 본래 문자열은 따옴표로 감싸는 건데, 어째서인지 그 뒤에 '.freeze'를 포함해야 문자열인듯한 풍조가 되어서, 아니, 그건 좀 아니잖아, 같은 생각이 들죠.

Matz: 아무튼, 구현하는 측에서는 최적화를 하나 넣기만 했을 뿐인데, 이러한 사회적 현상이 일어날 것이라고는 예상하지 못했기 때문에, 이건 정말 예상하지 못한 커뮤니티의 반응이랄까, 이후에 다시 나온 재제안을,

마츠다: 제재안은 저네요.

Matz: 이거 매직 코멘트 같은 방식으로 처리하는 게 어떨까요, 안그러면 이런 PR을 계속해서 받게 될지도 모르는데, 같은 이야기를 들어서, 그러한 사회적인 배경까지 생각해서 다시 그 제안을 고민해보니 사실은 별로 하고 싶지 않은데, 비호환이고, 다른 처리 계통에 대한 작업도 생기고, 정말 하고 싶지는 않은데, 그래도 있었으면 하는 마음은 이해가 되어서 그래서 도입에 대해서 진지하게 고민하기 시작했죠. 그리고 생각하다 보니, 뭐, 여기서 비호환 넣을거라면, 나중에 Ruby 3.0 같이 비호환을 넣어도 되는 시점에 전부 처리하고, 리터럴 문자열을 얼려서 쓴다, 같은 매직코멘트만 미리 넣으면 어떨까, 하는 제안보다 한 발 더 나간 이야기를 하고, 루비 3.0에서는 그렇게 하겠습니다. 라고 하고, 대신 Ruby 2에서는 이 동작을 변경할 수 없으니까, 매직 코멘트를 넣겠습니다, 하고. 루비 3에서는 정 반대로, 오래된 라이브러리들을 위해서 리터럴 문자열을 Mutable하게 해주는 매직 코멘트를 사용할 수 있도록 하는게 좋지 않을까, 하는 이야기까지 하고 있었더니, 결과적으로 현 시점에 매직 코멘트를 추가했어요. 그리고 좀 난폭하지만, 루비 자체에 커맨드라인 옵션을 추가해서 이 옵션으로 실행하면 프로그램의 모든 리터럴 문자열을 얼리게 됩니다, 하는,

마츠다: Ruby 3 모드로 (웃음)

Matz: Ruby 3 모드로. 루비 3에서는 일단 영향을 지켜보겠지만, 내심으로는 얼리는 걸 기본값으로 쓰고 싶다고 생각해요.

미야가와: 매직 코멘트 이외의 방법으로 리터럴 문자열을 mutable하게 만드는건 생각하지 않으셨나요?

Matz: dup 메소드를 쓰면 되고, 그리고 프로그램 내부에서는 빈 문자열을 처음에 대입하고, 거기에 다른 문자열을 추가하는 식으로 사용하는 경우도 꽤 있거든요. 그러한 경우에는 예를 들자면, String.new를 통해서 생성하게 되면, 이렇게 만들면 mutable, 변경 가능하기 때문에, 그런 식으로 사용하면 되지 않을까, 해요.

마츠다: 아, 그 이야기에는 꽤 놀랐었네요. 매직코멘트가 있었으면 했을 뿐인데, 그럼 Ruby 3에서는 Immutable로 하죠, 하시니까.

Matz: 뭐, 요구받은 것보다 앞서나갔죠.

마츠다: 아무도 예상하지 못했죠. 거기까지는.

Matz: 도를 넘어가는 것이 마츠모토의 좋은 점이기도 하고, 나쁜 점이기도 하죠.

(전원 웃음)

미야가와: 하지만 이것도 실제로 쓰여보기 전에는 어떨지 모른다고 할까, 그, 자신의 코드에 있는 리터럴 문자열을 만들어서 사용하는 거라면 충분히 대응할 수 있을텐데, 그 문자열이 이런저런 gem에서 사용된 결과, 변경되는 경우도 종종 있잖아요.

Matz: 그런 경우는 큰일이죠. 그래서 소노다 군에게 부탁해서, 리터럴 문자열 변경 시도로 인한 에러가 발생했을 경우에 어디서 만들었는지에 대한 정보를 저장해두고, '이 문자열은 어디서 만들어진 리터럴 문자열입니다.'라고 할 수 있도록 만들었어요, 지금은 아마 옵션일텐데.

마츠다: 오, 이미 구현된건가요?

Matz: 이미 되어 있어요. 그래서 그런 문제가 발생했을 경우에, 에러를 발생시킨 문자열이 어디서 생성되었는지 디버깅할 수 있어요.

미야가와: 그건 런타임 시점에서 문자열 객체에 정보를 넣거나 하는건가요?

Matz: 네. 문자열 객체에 관련한 정보를 추가하도록 했어요.

미야가와: 그게 있으면 문제가 생겨도 어디서 문제가 생겼는지 바로 알 수 있으니 고치기 쉽겠네요.
